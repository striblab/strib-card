<:Head>
</:Head>

<main>
  <div class="strib-card cf">
    <div class="output">
      <div class="output-inner">
        <canvas ref:output class="output-preview" width="1200" height="630"></canvas>
      </div>
    </div>

    <div class="controls">
      <div class="controls-inner">
        <h1>Strib card</h1>

        <p>Use the controls below to create an image to use on social media.  Use the button at the bottom to download the image.</p>

        <form>
          <h2>Format</h2>
          <label for="size-select" class="sr-only">Size</label>
          <select id="size-select" bind:value="size">
            {{#each Object.entries(sizes) as [si, s]}}
              <option value="{{si}}">{{si}}</option>
            {{/each}}
          </select>
          <small>Each site has its own aspect ratio and ideal size.</small>


          <h2>Quote</h2>
          <label for="quote-input" class="sr-only">Quote</label>
          <textarea id="quote-input" bind:value="quote"></textarea>

          <label for="quote-alignment" class="sr-only">Quote alignment</label>
          <div class="button-group" id="quote-alignment" role="group">
            <button on:click="proxySet(event, 'quoteAlignX', 'left')" class="{{ quoteAlignX === 'left' ? '' : 'light' }}">
              <i class="fa fa-align-left"></i><span class="sr-only">Left</span>
            </button>

            <button on:click="proxySet(event, 'quoteAlignX', 'center')" class="{{ quoteAlignX === 'center' ? '' : 'light' }}">
              <i class="fa fa-align-center"></i><span class="sr-only">Center</span>
            </button>

            <button on:click="proxySet(event, 'quoteAlignX', 'right')" class="{{ quoteAlignX === 'right' ? '' : 'light' }}">
              <i class="fa fa-align-right"></i><span class="sr-only">Center</span>
            </button>
          </div>

          <div class="form-element-inline">
            <label for="quote-size">Quote size</label>
            <input id="quote-size" bind:value="quoteSize" type="range" min="10" max="100">
          </div>


          <h2>Attribution</h2>
          <label for="attribution-input" class="sr-only">Attribution</label>
          <input type="text" id="attribution-input" bind:value="attribution">

          <div class="form-element-inline">
            <label for="attribution-size">Attribution size</label>
            <input id="attribution-size" bind:value="attributionSize" type="range" min="10" max="100">
          </div>


          <h2>Text</h2>
          <label for="quote-font">Font</label>
          <div class="button-group button-group-small" id="quote-font" role="group">
            {{#each fonts as f}}
              <button on:click="proxySet(event, 'font', f)"
                class="{{ font === f ? '' : 'light' }}"
                title="Change font to {{ f }}">
                <span class="font-{{ kebab(f) }}">Aa</span>
                <span class="sr-only">Change font to {{ f }}</span>
              </button>
            {{/each}}
          </div>

          <label for="text-placement">Text placement</label>
          <div class="button-group" id="text-placement" role="group">
            {{#each Object.entries(textPlacements) as l}}
              <button on:click="proxySet(event, 'textPlacement', l[0])" class="{{ textPlacement === l[0] ? '' : 'light' }}" title="{{ l[1].description }}">
                {{{ l[1].name }}}
              </button>
            {{/each}}
          </div>

          <label for="text-effects">Text effects</label>
          <div class="button-group" id="text-effects" role="group">
            <button on:click="proxyToggle(event, 'dropShadow')" class="{{ dropShadow ? '' : 'light' }}">
              Drop shadow
            </button>
          </div>


          <h2>Background image</h2>
          <label for="background-image" class="sr-only">Background image</label>
          <div ref:bgImage id="background-image"
            on:dragover="proxySet(event, 'bgImageOver', true)"
            on:dragenter="proxySet(event, 'bgImageOver', true)"
            on:dragleave="proxySet(event, 'bgImageOver', false)"
            on:dragend="proxySet(event, 'bgImageOver', false)"
            on:drop="imageDrop(event)"
            class="file-upload-container {{ bgImageOver ? 'drag-over' : '' }}">
            <span>
              <i class="fa fa-download"></i><br>
              Drag file here
            </span>
          </div>

          <label for="bg-placement" class="sr-only">Background image placement</label>
          <div class="button-group" id="bg-placement" role="group">
            {{#each Object.entries(bgPlacements) as l}}
              <button on:click="proxySet(event, 'bgPlacement', l[0])" class="{{ bgPlacement === l[0] ? '' : 'light' }}" title="{{ l[1].description }}">
                {{{ l[1].name }}}
              </button>
            {{/each}}

            <button on:click="proxySet(event, 'bgImage', null)" class="button-outline {{ !bgImage ? '' : 'light' }}">
              <i class="fa fa-close"></i><span class="sr-only">No background image</span>
            </button>
          </div>


          <h2>Colors</h2>
          <label for="background-color">Background color</label>
          <ColorPicker id="background-color" bind:color="backgroundColor" />

          <label for="background-color">Foreground color</label>
          <ColorPicker id="background-color" bind:color="foregroundColor" />


          <h2>Logo</h2>
          <label for="logo" class="sr-only">Logo</label>
          <div class="button-group" id="logo" role="group">
            {{#each Object.entries(logos) as l}}
              <button on:click="proxySet(event, 'logo', l[0])" class="button-outline {{ logo === l[0] ? '' : 'light' }}">
                <i class="strib-icon strib-strib-star" style="color: {{ l[1].color }}"></i>
                {{ l[1].suffix ? l[1].suffix : '' }}
              </button>
            {{/each}}

            <button on:click="proxySet(event, 'logo', null)" class="button-outline {{ !logo ? '' : 'light' }}">
              <i class="fa fa-close"></i><span class="sr-only">No logo</span>
            </button>
          </div>

          <label for="logo-placement" class="sr-only">Logo placement</label>
          <div class="button-group" id="logo-placement" role="group">
            {{#each Object.entries(logoPlacements) as l}}
              <button on:click="proxySet(event, 'logoPlacement', l[0])" class="{{ logoPlacement === l[0] ? '' : 'light' }}">
                {{{ l[1] }}}
              </button>
            {{/each}}
          </div>

          <div class="form-element-inline">
            <label for="logo-proportion">Logo size</label>
            <input id="logo-proportion" bind:value="logoProportion" type="range" min="0.5" max="4" step="0.1">
          </div>

          <button on:click="download(event)">Download</button>
          <a ref:download class="download-placeholder" href="#download" download="">Download placeholder</a>

          <div class="preload-images">
            {{#each logos as l}}
              <img src="images/{{l}}.svg" alt="Star tribune logo">
            {{/each}}
          </div>
        </form>
      </div>
    </div>
  </div>
</main>

<script>
import ColorPicker from './components/color-picker.svelte.html';
import WebFont from 'webfontloader';
import { observeMany } from 'svelte-extras';

export default {
  components: {
    ColorPicker
  },

  oncreate: function() {
    // All the observes that should cause render
    let renderables = [
      'quote',
      'attribution',
      'quoteAlignX',
      'padding',
      'quoteSize',
      'attributionSize',
      'font',
      'backgroundColor',
      'foregroundColor',
      'size',
      'logo',
      'logoProportion',
      'logoPlacement',
      'bgImage',
      'bgPlacement',
      'dropShadow',
      'textPlacement'
    ];
    this.observeMany(renderables, this.render, { init: false });

    // Wait for fonts to load, set message
    let defaultQuote = this.get('quote');
    this.set({ quote: 'Loading fonts...' });
    WebFont.load({
      custom: {
        families: this.get('fonts')
      },
      active: () => {
        this.set({ quote: defaultQuote });
      }
    });
  },

  data: () => {
    return {
      quote: '"A quote would go here."',
      attribution: 'A. Name',
      alignY: 'center',
      quoteAlignX: 'left',
      backgroundColor: '#7ABDFF',
      foregroundColor: '#FFFFFF',
      fonts: [
        'Benton Sans',
        'Benton Sans Condensed',
        'Popular',
        'Popular Light',
        'Popular Medium',
        'Poynter Serif',
        'Whitman Display',
        'Whitman Display Condensed Bold',
        'Whitman Display Compressed Bold',
        'Whitman OSF',
        'Menlo'
      ],
      font: 'Benton Sans',
      quoteSize: 56,
      attributionSize: 40,
      padding: 50,
      sizes: {
        Facebook: [1200, 630],
        Twitter: [1024, 512],
        Instagram: [1080, 1080]
      },
      size: 'Facebook',
      logos: {
        starBlack: {
          file: 'strib-star-black.svg',
          ratio: 65.6 / 58,
          color: '#000000',
          baseWidth: 75
        },
        starGreen: {
          file: 'strib-star-green.svg',
          ratio: 65.6 / 58,
          color: '#00824a',
          baseWidth: 75
        },
        starWhite: {
          file: 'strib-star-white.svg',
          ratio: 65.6 / 58,
          color: '#EEEEEE',
          baseWidth: 75
        },
        logoBlack: {
          file: 'strib-logo-black.svg',
          ratio: 160 / 25,
          color: '#000000',
          suffix: 'ST',
          baseWidth: 225
        },
        logoWhite: {
          file: 'strib-logo-white.svg',
          ratio: 160 / 25,
          color: '#EEEEEE',
          suffix: 'ST',
          baseWidth: 225
        }
      },
      logo: 'starWhite',
      logoProportion: 1,
      logoPlacements: {
        topLeft: '&boxdr;',
        topRight: '&boxdl;',
        bottomLeft: '&boxur;',
        bottomRight: '&boxul;'
      },
      logoPlacement: 'bottomRight',
      bgPlacements: {
        stretch: {
          description: 'Stretch to fit canvas, does not preserve aspect ratio',
          name: 'Stretch'
        },
        fill: {
          description: 'Fill canvas, preserve ratio',
          name: 'Fill'
        }
      },
      bgPlacement: 'fill',
      textPlacements: {
        top: {
          description: 'Move quote and attribution to top',
          name: 'Top'
        },
        middle: {
          description: 'Move quote and attribution to the middle',
          name: 'Middle'
        },
        bottom: {
          description: 'Move quote and attribution to bottom',
          name: 'Bottom'
        }
      },
      textPlacement: 'middle'
    };
  },

  methods: {
    observeMany,

    // Upload image
    imageDrop: async function(e) {
      this.proxySet(e, 'bgImageOver', false);

      if (e && e.dataTransfer && e.dataTransfer.files) {
        let file = e.dataTransfer.files[0];

        if (file.type.match(/image*/i)) {
          let image = await this.loadImageFromFile(file);
          this.set({ bgImage: image });
        } else {
          this.set({ bgImageError: 'Please provide an image file.' });
        }
      } else {
        this.set({ bgImageError: 'No files found.' });
      }
    },

    // Load image form file
    loadImageFromFile: async function(f) {
      return new Promise((resolve, reject) => {
        let reader = new FileReader();

        // Wait for loading
        reader.onload = () => {
          // Make new image object and load
          let image = new Image();
          image.onload = () => {
            resolve(image);
          };
          image.onerror = reject;

          // Use reader result as image
          image.src = reader.result;
        };

        // Handler error on file
        reader.onerror = reject;

        // Read actual file
        reader.readAsDataURL(f);
      });
    },

    // load image from URL
    loadImage: async function(source) {
      return new Promise((resolve, reject) => {
        // Make new image object and load
        let image = new Image();
        image.onload = () => {
          resolve(image);
        };
        image.onerror = reject;

        // Use reader result as image
        image.src = source;
      });
    },

    // Download
    download: async function(e) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }

      // Make sure render is correct
      await this.render();

      // Put together download
      let canvas = this.refs.output;
      let download = this.refs.download;
      let data = canvas.toDataURL();
      download.href = data;
      download.download = 'make-name-TODO.png';
      download.click();
    },

    // Main render function
    render: async function() {
      let canvas = this.refs.output;
      let context = canvas.getContext('2d');
      let padding = this.get('padding');

      // Formatting
      let quote = this.get('quote')
        .trim()
        .replace(/"(\w)/g, '“$1')
        .replace(/(\S)"/g, '$1”')
        .replace(/--/g, '—');
      let attribution = this.get('attribution').trim();

      // Set up canvas
      canvas.width = this.get('sizes')[this.get('size')][0];
      canvas.height = this.get('sizes')[this.get('size')][1];

      // Set the background color
      context.fillStyle = this.get('backgroundColor');
      context.fillRect(0, 0, canvas.width, canvas.height);

      // Add the image
      if (this.get('bgImage')) {
        let bgImage = this.get('bgImage');
        let place = this.get('bgPlacement');
        let draw = [0, 0, canvas.width, canvas.height];

        // Stetch is easy
        if (place === 'stretch') {
          // Use default
        } else if (place === 'fill') {
          // Fill can be a bit complex
          let bgRatio = bgImage.width / bgImage.height;
          let canvasRatio = canvas.width / canvas.height;

          if (bgRatio === canvasRatio) {
            // Use default
          } else if (bgRatio < canvasRatio) {
            let scale = canvas.width / bgImage.width;
            draw = [
              0,
              (bgImage.height * scale - canvas.height) / 2 * -1,
              bgImage.width * scale,
              bgImage.height * scale
            ];
          } else {
            let scale = canvas.height / bgImage.height;
            draw = [
              (bgImage.width * scale - canvas.width) / 2 * -1,
              0,
              bgImage.width * scale,
              bgImage.height * scale
            ];
          }
        }

        context.drawImage(
          this.get('bgImage'),
          draw[0],
          draw[1],
          draw[2],
          draw[3]
        );
      }

      // Add logo
      if (this.get('logo')) {
        let logo = this.get('logos')[this.get('logo')];
        let logoWidth = logo.baseWidth * parseFloat(this.get('logoProportion'));
        let logoPlacement = this.get('logoPlacement');

        let logoImage = await this.loadImage(`images/${logo.file}`);
        context.drawImage(
          logoImage,
          logoPlacement === 'topLeft' || logoPlacement === 'bottomLeft'
            ? padding
            : canvas.width - padding - logoWidth,
          logoPlacement === 'topLeft' || logoPlacement === 'topRight'
            ? padding
            : canvas.height - padding - logoWidth / logo.ratio,
          logoWidth,
          logoWidth / logo.ratio
        );
      }

      // Lay out the text
      context.fillStyle = this.get('foregroundColor');
      let maxWidth = canvas.width - padding * 2;
      let lines = this.layoutText(
        quote,
        maxWidth,
        this.get('font'),
        this.get('quoteSize')
      );

      let attrLines = this.layoutText(
        '    — ' + attribution,
        maxWidth,
        this.get('font'),
        this.get('attributionSize')
      );
      attrLines.forEach(l => (l.alignment = 'right'));
      lines = lines.concat(attrLines);
      let height = lines.reduce((t, l) => {
        return t + l.size * 1.2;
      }, 0);

      // Draw the text
      let lineY = canvas.height / 2 - height / 2 + this.get('quoteSize') / 2;
      if (this.get('textPlacement') === 'top') {
        lineY = padding + this.get('quoteSize') / 2;
      } else if (this.get('textPlacement') === 'bottom') {
        lineY = canvas.height - height - padding + this.get('quoteSize') / 2;
      }
      lines.forEach(l => {
        let x = padding;
        let alignment = l.alignment || this.get('quoteAlignX');
        if (alignment == 'right') {
          x = canvas.width - padding;
        } else if (alignment == 'center') {
          x = canvas.width / 2;
        }
        context.textAlign = alignment;
        context.font = `${l.size}px ${this.get('font')}`;

        if (this.get('dropShadow')) {
          context.shadowOffsetX = 4;
          context.shadowOffsetY = 4;
          context.shadowColor = 'rgba(0, 0, 0, 0.8)';
          context.shadowBlur = 15;
        }

        context.fillText(l.text, x, lineY);
        lineY += l.size * 1.2;
      });
    },

    // Takes some text and some parameters and breaks into
    // multiple lines.
    layoutText(text, maxWidth, font, size) {
      let canvas = this.refs.output;
      let context = canvas.getContext('2d');
      let lines = [];
      let position = 0;
      let buffer = '';
      context.font = `${size}px ${font}`;
      let die = 0;
      while (position < text.length && die < 10000) {
        die++;
        let char = text[position];
        if (char == '\n') {
          lines.push({
            text: buffer,
            width: context.measureText(buffer).width,
            size
          });
          position++;
          buffer = '';
          continue;
        }

        buffer += char;
        let metric = context.measureText(buffer);
        if (metric.width > maxWidth) {
          let words = buffer.trim().split(' ');
          if (words.length > 1) {
            let last = words.pop();
            if (context.measureText(last).width < maxWidth) {
              //check for overrun
              position -= last.length + 1;
            }
          } else {
            position++;
          }
          words = words.join(' ');
          lines.push({
            text: words,
            width: context.measureText(words).width,
            size
          });
          buffer = '';
        }
        position++;
      }
      if (buffer) {
        lines.push({
          text: buffer.trim(),
          width: context.measureText(buffer).width,
          size
        });
      }
      return lines;
    },

    // Load fonts
    loadFonts() {},

    // Proxy around set for events
    proxySet(e, k, v) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }

      this.set({ [k]: v });
    },

    proxyToggle(e, k) {
      if (e && e.preventDefault) {
        e.preventDefault();
      }
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }

      this.set({ [k]: !this.get(k) });
    }
  },

  helpers: {
    // https://gist.github.com/tdukart/b87afb278c41245741ae7a0c355a0a0b
    kebab: input => {
      var result = input;

      // Convert camelCase capitals to kebab-case.
      result = result.replace(/([a-z][A-Z])/g, function(match) {
        return match.substr(0, 1) + '-' + match.substr(1, 1).toLowerCase();
      });

      // Convert non-camelCase capitals to lowercase.
      result = result.toLowerCase();

      // Convert non-alphanumeric characters to hyphens
      result = result.replace(/[^-a-z0-9]+/g, '-');

      // Remove hyphens from both ends
      result = result.replace(/^-+/, '').replace(/-$/, '');

      return result;
    }
  }
};
</script>
